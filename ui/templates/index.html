<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Phishing Detection - Production Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: rgba(255,255,255,0.9);
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-online {
            background: #10b981;
            box-shadow: 0 0 10px #10b981;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #6b7280;
            font-weight: 500;
        }

        .metric-value {
            color: #1f2937;
            font-weight: 600;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
            margin-bottom: 15px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: #667eea;
            color: white;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-input-label:hover {
            background: #5568d3;
        }

        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 12px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background 0.3s;
            margin-top: 10px;
        }

        button:hover {
            background: #059669;
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        button.secondary {
            background: #667eea;
        }

        button.secondary:hover {
            background: #5568d3;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        .prediction-result {
            margin-top: 20px;
            padding: 15px;
            background: #f3f4f6;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .prediction-result h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .probability-bar {
            margin: 10px 0;
        }

        .probability-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .progress {
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .alert-success {
            background: #d1fae5;
            color: #065f46;
            border-left: 4px solid #10b981;
        }

        .alert-error {
            background: #fee2e2;
            color: #991b1b;
            border-left: 4px solid #ef4444;
        }

        .alert-warning {
            background: #fef3c7;
            color: #92400e;
            border-left: 4px solid #f59e0b;
        }

        .loader {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .version-item {
            background: #f9fafb;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .version-item.current {
            border-left-color: #10b981;
            background: #d1fae5;
        }

        .version-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .version-id {
            font-weight: 600;
            color: #1f2937;
        }

        .version-date {
            font-size: 12px;
            color: #6b7280;
        }

        .version-metrics {
            font-size: 14px;
            color: #4b5563;
            margin-top: 5px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .badge-success {
            background: #10b981;
            color: white;
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .file-item {
            padding: 8px;
            background: #f9fafb;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item.valid {
            border-left: 3px solid #10b981;
        }

        .file-item.invalid {
            border-left: 3px solid #ef4444;
        }

        .small-btn {
            padding: 4px 12px;
            font-size: 12px;
            margin-top: 5px;
            width: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Voice Phishing Detection System</h1>
        <p class="subtitle">Production-Grade ML Pipeline with Validation, Versioning & Rollback</p>

        <div class="dashboard">
            <!-- System Status -->
            <div class="card">
                <h2>System Status</h2>
                <div class="metric">
                    <span class="metric-label">
                        <span class="status-indicator status-online"></span>
                        API Status
                    </span>
                    <span class="metric-value" id="modelStatus">Online</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Uptime</span>
                    <span class="metric-value" id="uptime">Loading...</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Current Version</span>
                    <span class="metric-value" id="currentVersion">Loading...</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Updated</span>
                    <span class="metric-value" id="lastUpdate">Just now</span>
                </div>
            </div>

            <!-- Single Prediction -->
            <div class="card">
                <h2>Single File Prediction</h2>
                <div class="file-input-wrapper">
                    <input type="file" id="singleFile" accept=".wav,.mp3,.flac,.ogg">
                    <label for="singleFile" class="file-input-label">Choose Audio File</label>
                </div>
                <div id="singleFileName"></div>
                <button onclick="predictSingle()">Predict</button>
                <div class="loader" id="singleLoader"></div>
                <div id="singleResult"></div>
            </div>

            <!-- Upload with Class Label -->
            <div class="card">
                <h2>Upload Training Data</h2>
                <label style="display: block; margin-bottom: 8px; color: #6b7280; font-weight: 500;">Select Class Label:</label>
                <select id="classLabel">
                    <option value="Suspicious">üö® Suspicious (Phishing)</option>
                    <option value="Legitimate">‚úÖ Legitimate (Safe)</option>
                </select>

                <div class="file-input-wrapper">
                    <input type="file" id="uploadFiles" multiple accept=".wav,.mp3,.flac,.ogg">
                    <label for="uploadFiles" class="file-input-label">Choose Multiple Files</label>
                </div>
                <div id="uploadFileList"></div>
                <button onclick="uploadWithValidation()">Upload & Validate</button>
                <div class="loader" id="uploadLoader"></div>
                <div id="uploadResult"></div>
            </div>
        </div>

        <!-- Model Versions -->
        <div class="card" style="margin-bottom: 20px;">
            <h2>Model Version Control</h2>
            <button class="secondary" onclick="loadVersions()">Refresh Versions</button>
            <div id="versionsContainer" style="margin-top: 20px;">
                <p style="color: #6b7280;">Click "Refresh Versions" to load version history...</p>
            </div>
        </div>

        <!-- Retrain Section -->
        <div class="card">
            <h2>Retrain Model</h2>
            <p style="color: #6b7280; margin-bottom: 15px;">Upload files above, then trigger retraining to create a new model version.</p>
            <button class="danger" onclick="triggerRetraining()">üîÑ Trigger Retraining</button>
            <div class="loader" id="retrainLoader"></div>
            <div id="retrainResult"></div>
        </div>

        <!-- Model Metrics -->
        <div class="card">
            <h2>Model Performance Metrics</h2>
            <div id="metricsContainer">
                <p style="color: #6b7280;">Loading metrics...</p>
            </div>
        </div>
    </div>

    <script>
        // Update system status
        async function updateStatus() {
            try {
                const response = await fetch('/health');
                const data = await response.json();

                document.getElementById('uptime').textContent =
                    Math.floor(data.uptime_seconds / 60) + ' minutes';
                document.getElementById('lastUpdate').textContent = 'Just now';

                // Load current version
                loadCurrentVersion();
            } catch (error) {
                console.error('Error fetching status:', error);
            }
        }

        // Load current version
        async function loadCurrentVersion() {
            try {
                const response = await fetch('/api/v2/versions');
                const data = await response.json();

                if (data.current_version) {
                    document.getElementById('currentVersion').textContent =
                        data.current_version.version_id.substring(0, 15) + '...';
                }
            } catch (error) {
                console.error('Error loading version:', error);
            }
        }

        // Show selected file name
        document.getElementById('singleFile').addEventListener('change', function(e) {
            const fileName = e.target.files[0]?.name || '';
            document.getElementById('singleFileName').innerHTML =
                fileName ? `<small style="color: #6b7280;">Selected: ${fileName}</small>` : '';
        });

        // Show upload file list
        document.getElementById('uploadFiles').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                let html = '<div class="file-list">';
                files.forEach(file => {
                    html += `<div class="file-item">üìé ${file.name}</div>`;
                });
                html += '</div>';
                document.getElementById('uploadFileList').innerHTML = html;
            }
        });

        // Single file prediction
        async function predictSingle() {
            const fileInput = document.getElementById('singleFile');
            const loader = document.getElementById('singleLoader');
            const resultDiv = document.getElementById('singleResult');

            if (!fileInput.files[0]) {
                resultDiv.innerHTML = '<div class="alert alert-error">Please select a file</div>';
                return;
            }

            const formData = new FormData();
            formData.append('file', fileInput.files[0]);

            loader.style.display = 'block';
            resultDiv.innerHTML = '';

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                loader.style.display = 'none';

                if (response.ok) {
                    let html = `
                        <div class="prediction-result">
                            <h3>Prediction: ${data.predicted_class}</h3>
                            <p><strong>Confidence:</strong> ${(data.confidence * 100).toFixed(2)}%</p>
                    `;

                    if (data.probabilities) {
                        html += '<h4 style="margin-top: 15px;">All Probabilities:</h4>';
                        for (const [className, prob] of Object.entries(data.probabilities)) {
                            html += `
                                <div class="probability-bar">
                                    <div class="probability-label">
                                        <span>${className}</span>
                                        <span>${(prob * 100).toFixed(1)}%</span>
                                    </div>
                                    <div class="progress">
                                        <div class="progress-bar" style="width: ${prob * 100}%"></div>
                                    </div>
                                </div>
                            `;
                        }
                    }

                    if (data.visualizations) {
                        html += '<h4 style="margin-top: 20px;">Audio Analysis:</h4>';
                        
                        if (data.visualizations.waveform) {
                            html += `
                                <div style="margin-top: 10px;">
                                    <p><strong>Waveform</strong></p>
                                    <img src="data:image/png;base64,${data.visualizations.waveform}" style="width: 100%; border-radius: 8px;">
                                    <p style="font-size: 0.9em; color: #6b7280; margin-top: 5px;">
                                        <em>Shows the amplitude of the audio signal over time. Sudden spikes may indicate aggressive speech patterns common in vishing.</em>
                                    </p>
                                </div>
                            `;
                        }
                        
                        if (data.visualizations.spectrogram) {
                            html += `
                                <div style="margin-top: 10px;">
                                    <p><strong>Mel Spectrogram</strong></p>
                                    <img src="data:image/png;base64,${data.visualizations.spectrogram}" style="width: 100%; border-radius: 8px;">
                                    <p style="font-size: 0.9em; color: #6b7280; margin-top: 5px;">
                                        <em>Visualizes the energy of frequencies over time. High energy in higher frequencies can indicate stress or urgency in the speaker's voice.</em>
                                    </p>
                                </div>
                            `;
                        }
                        
                        if (data.visualizations.mfcc) {
                            html += `
                                <div style="margin-top: 10px;">
                                    <p><strong>MFCC Features</strong></p>
                                    <img src="data:image/png;base64,${data.visualizations.mfcc}" style="width: 100%; border-radius: 8px;">
                                    <p style="font-size: 0.9em; color: #6b7280; margin-top: 5px;">
                                        <em>Represents the short-term power spectrum of sound. These features are critical for distinguishing between human speech characteristics and synthetic/robotic voices.</em>
                                    </p>
                                </div>
                            `;
                        }
                        
                        html += `
                            <div style="margin-top: 20px; padding: 15px; background: #eef2ff; border-radius: 8px; border-left: 4px solid #667eea;">
                                <h4 style="color: #4f46e5; margin-bottom: 5px;">Feature Interpretation</h4>
                                <ul style="list-style-type: disc; margin-left: 20px; color: #4b5563; font-size: 0.95em;">
                                    <li><strong>Waveform:</strong> Visualizes the loudness and silence patterns. Long silences followed by loud bursts can indicate scripted pauses or aggressive interruptions.</li>
                                    <li><strong>Mel Spectrogram:</strong> Maps the intensity of different frequencies. Phishing calls often exhibit specific frequency patterns associated with urgency or synthetic audio generation.</li>
                                    <li><strong>MFCCs:</strong> Captures the "timbre" or quality of the voice. This is the most important feature for detecting deepfakes or voice changers often used in vishing attacks.</li>
                                </ul>
                            </div>
                        `;
                    }

                    html += '</div>';
                    resultDiv.innerHTML = html;
                } else {
                    resultDiv.innerHTML = `<div class="alert alert-error">${data.error}</div>`;
                }
            } catch (error) {
                loader.style.display = 'none';
                resultDiv.innerHTML = `<div class="alert alert-error">Error: ${error.message}</div>`;
            }
        }

        // Upload with validation
        async function uploadWithValidation() {
            const fileInput = document.getElementById('uploadFiles');
            const classLabel = document.getElementById('classLabel').value;
            const loader = document.getElementById('uploadLoader');
            const resultDiv = document.getElementById('uploadResult');

            if (!fileInput.files.length) {
                resultDiv.innerHTML = '<div class="alert alert-error">Please select files</div>';
                return;
            }

            const formData = new FormData();
            for (const file of fileInput.files) {
                formData.append('files', file);
            }
            formData.append('class_label', classLabel);

            loader.style.display = 'block';
            resultDiv.innerHTML = '';

            try {
                const response = await fetch('/api/v2/upload_with_label', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                loader.style.display = 'none';

                let html = '';

                if (data.valid_count > 0) {
                    html += `<div class="alert alert-success">
                        <strong>‚úì ${data.valid_count} files uploaded successfully to "${classLabel}"</strong>
                    `;

                    if (data.valid_files && data.valid_files.length > 0) {
                        html += '<div class="file-list" style="margin-top: 10px;">';
                        data.valid_files.forEach(file => {
                            html += `<div class="file-item valid">‚úì ${file}</div>`;
                        });
                        html += '</div>';
                    }
                    html += '</div>';
                }

                if (data.invalid_count > 0) {
                    html += `<div class="alert alert-warning">
                        <strong>‚ö† ${data.invalid_count} files failed validation</strong>
                    `;

                    if (data.invalid_files) {
                        html += '<div class="file-list" style="margin-top: 10px;">';
                        data.invalid_files.forEach(item => {
                            html += `<div class="file-item invalid">‚úó ${item.file}<br><small>${item.error}</small></div>`;
                        });
                        html += '</div>';
                    }
                    html += '</div>';
                }

                resultDiv.innerHTML = html;

            } catch (error) {
                loader.style.display = 'none';
                resultDiv.innerHTML = `<div class="alert alert-error">Error: ${error.message}</div>`;
            }
        }

        // Load versions
        async function loadVersions() {
            const container = document.getElementById('versionsContainer');
            container.innerHTML = '<p style="color: #6b7280;">Loading versions...</p>';

            try {
                const response = await fetch('/api/v2/versions');
                const data = await response.json();

                if (data.versions.length === 0) {
                    container.innerHTML = '<p style="color: #6b7280;">No versions found</p>';
                    return;
                }

                let html = '';
                data.versions.forEach(version => {
                    const isCurrent = data.current_version &&
                                    version.version_id === data.current_version.version_id;

                    html += `
                        <div class="version-item ${isCurrent ? 'current' : ''}">
                            <div class="version-header">
                                <div>
                                    <span class="version-id">${version.version_id}</span>
                                    ${isCurrent ? '<span class="badge badge-success">CURRENT</span>' : ''}
                                </div>
                                <span class="version-date">${new Date(version.created_at).toLocaleString()}</span>
                            </div>
                            <div class="version-metrics">
                                ${version.metrics?.accuracy ? `Accuracy: ${typeof version.metrics.accuracy === 'number' ? (version.metrics.accuracy * 100).toFixed(2) + '%' : version.metrics.accuracy}` : ''}
                                ${version.metrics?.training_samples ? ` | Samples: ${version.metrics.training_samples}` : ''}
                            </div>
                            ${!isCurrent ? `<button class="small-btn secondary" onclick="rollbackVersion('${version.version_id}')">Rollback to This Version</button>` : ''}
                        </div>
                    `;
                });

                container.innerHTML = html;

            } catch (error) {
                container.innerHTML = `<div class="alert alert-error">Error loading versions: ${error.message}</div>`;
            }
        }

        // Rollback version
        async function rollbackVersion(versionId) {
            if (!confirm(`Are you sure you want to rollback to version ${versionId}?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/v2/versions/${versionId}/rollback`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    alert(`‚úì Successfully rolled back to ${versionId}\n\nPlease refresh the page to load the restored model.`);
                    loadVersions();
                    updateStatus();
                } else {
                    alert(`‚úó Rollback failed: ${data.error}`);
                }

            } catch (error) {
                alert(`‚úó Error: ${error.message}`);
            }
        }

        // Trigger retraining
        async function triggerRetraining() {
            if (!confirm('Start model retraining? This will create a new model version.')) {
                return;
            }

            const loader = document.getElementById('retrainLoader');
            const resultDiv = document.getElementById('retrainResult');

            loader.style.display = 'block';
            resultDiv.innerHTML = '';

            try {
                const response = await fetch('/retrain', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({epochs: 30, batch_size: 32})
                });

                const data = await response.json();
                loader.style.display = 'none';

                if (response.ok) {
                    resultDiv.innerHTML = `
                        <div class="alert alert-success">
                            <p><strong>‚úì Retraining started!</strong></p>
                            <div style="margin-top: 15px;">
                                <strong>Progress:</strong>
                                <div class="progress" style="height: 30px; margin-top: 10px;">
                                    <div class="progress-bar" id="retrainProgress" style="width: 0%; transition: width 0.5s; text-align: center; line-height: 30px; color: white; font-weight: 600;">0%</div>
                                </div>
                                <p id="retrainMessage" style="margin-top: 10px; color: #6b7280;">Initializing...</p>
                            </div>
                        </div>
                    `;
                    pollRetrainingStatus();
                } else {
                    resultDiv.innerHTML = `<div class="alert alert-error">${data.error || data.message}</div>`;
                }
            } catch (error) {
                loader.style.display = 'none';
                resultDiv.innerHTML = `<div class="alert alert-error">Error: ${error.message}</div>`;
            }
        }

        // Poll retraining status
        let retrainingPollInterval = null;

        async function pollRetrainingStatus() {
            if (retrainingPollInterval) {
                clearInterval(retrainingPollInterval);
            }

            retrainingPollInterval = setInterval(async () => {
                try {
                    const response = await fetch('/retrain_status');
                    const data = await response.json();

                    const progressBar = document.getElementById('retrainProgress');
                    const messageEl = document.getElementById('retrainMessage');

                    if (progressBar && messageEl) {
                        progressBar.style.width = `${data.progress}%`;
                        progressBar.textContent = `${data.progress}%`;
                        messageEl.textContent = data.message || 'Processing...';

                        if (data.status === 'completed') {
                            clearInterval(retrainingPollInterval);
                            progressBar.style.backgroundColor = '#10b981';
                            messageEl.innerHTML = `
                                <strong style="color: #10b981;">‚úì Retraining completed!</strong><br>
                                <small>Version: ${data.version_id || 'N/A'}</small><br>
                                <small>Accuracy: ${data.metrics?.metrics?.accuracy || 'N/A'}</small>
                            `;
                            loadVersions();
                            setTimeout(() => window.location.reload(), 3000);
                        } else if (data.status === 'failed') {
                            clearInterval(retrainingPollInterval);
                            progressBar.style.backgroundColor = '#ef4444';
                            messageEl.innerHTML = `<strong style="color: #ef4444;">‚úó Failed: ${data.error}</strong>`;
                        }
                    }
                } catch (error) {
                    console.error('Error polling status:', error);
                }
            }, 2000);
        }

        // Load metrics
        async function loadMetrics() {
            try {
                const response = await fetch('/metrics');
                const data = await response.json();

                if (data.message) {
                    document.getElementById('metricsContainer').innerHTML =
                        `<p style="color: #6b7280;">${data.message}</p>`;
                    return;
                }

                let html = '<div class="metric-list">';
                for (const [key, value] of Object.entries(data)) {
                    if (key !== 'timestamp') {
                        html += `
                            <div class="metric">
                                <span class="metric-label">${key}</span>
                                <span class="metric-value">${typeof value === 'number' ? value.toFixed(4) : value}</span>
                            </div>
                        `;
                    }
                }
                html += '</div>';
                document.getElementById('metricsContainer').innerHTML = html;

            } catch (error) {
                console.error('Error loading metrics:', error);
            }
        }

        // Initialize
        updateStatus();
        loadMetrics();
        setInterval(updateStatus, 30000);
    </script>
</body>
</html>
